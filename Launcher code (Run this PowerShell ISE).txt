# Try production UNC path first, then fall back to script directory
$productionPath = '\\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appdata'
$scriptDirectory = if ($PSScriptRoot) { $PSScriptRoot } elseif ($MyInvocation.MyCommand.Path) { Split-Path -Parent $MyInvocation.MyCommand.Path } else { (Get-Location).Path }

# Helper function to test if RunMenu.txt exists in a path
function Test-RunMenuPath($basePath) {
    try {
        $testPath = Join-Path $basePath 'RunMenu.txt'
        return (Test-Path -LiteralPath $testPath -ErrorAction Stop)
    } catch {
        return $false
    }
}

# Determine the correct path to use
if (Test-RunMenuPath $productionPath) {
    $script:AgScriptsFolder = $productionPath
} elseif (Test-RunMenuPath $scriptDirectory) {
    $script:AgScriptsFolder = $scriptDirectory
} else {
    Write-Error "RunMenu.txt not found in either production path or script directory: $scriptDirectory"
    exit 1
}

# SECURITY FIX: Use direct dot-sourcing instead of ScriptBlock::Create to avoid EDR flagging
# EDR systems often flag dynamic code execution patterns like ScriptBlock::Create, Invoke-Expression,
# and similar constructs as they're commonly used in malicious scripts. Direct dot-sourcing of a file
# path is a safer pattern that's less likely to trigger security alerts.
$runMenuPath = Join-Path $script:AgScriptsFolder 'RunMenu.txt'
. $runMenuPath
