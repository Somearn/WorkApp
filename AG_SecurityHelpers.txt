# AG_SecurityHelpers.txt
# Security utilities for WorkApp
# Provides logging, validation, and integrity checking functions

$ErrorActionPreference = 'Stop'

# Initialize security log path
# NOTE: Log is created in user's TEMP directory. This means the log file can be 
# read/modified/deleted by the user. For true tamper-proof audit trail, consider 
# using a centralized logging system or Windows Event Log.
try {
    $programDataPath = $env:ProgramData
    if (-not [string]::IsNullOrWhiteSpace($programDataPath)) {
        $logDirectory = Join-Path $programDataPath 'WorkApp\Security'

        if (-not (Test-Path -LiteralPath $logDirectory)) {
            New-Item -ItemType Directory -Path $logDirectory -Force | Out-Null
        }

        $script:AG_SecurityLogPath = Join-Path $logDirectory 'SomearnTK_Security.log'
    }
    else {
        # Fallback to TEMP if ProgramData is not available
        $script:AG_SecurityLogPath = Join-Path $env:TEMP 'SomearnTK_Security.log'
    }
}
catch {
    # Fallback to TEMP if ProgramData is not writable or any error occurs
    $script:AG_SecurityLogPath = Join-Path $env:TEMP 'SomearnTK_Security.log'
}

# Known-good file hashes (SHA256) for integrity validation
# IMPORTANT: Update these hashes when modules are legitimately updated
$script:AG_ModuleHashes = @{
    'AG_MenuMain.txt' = @(
        # Add known-good hash after review
    )
    'AG_AppGroups.txt' = @()
    'AG_PhoneBookDirectory.txt' = @()
    'AG_SiteManager.txt' = @()
    'AG_DiagnosticsAndRepair.txt' = @()
    'AG_ScriptLauncherControlRoom.txt' = @()
    'AG_Themes.txt' = @()
    'AG_Settings.txt' = @()
}

function Write-SecurityLog {
    <#
    .SYNOPSIS
    Writes security events to log file for audit trail
    
    .PARAMETER EventType
    Type of security event (Load, Execute, Validation, Error, Warning)
    
    .PARAMETER Message
    Description of the security event
    
    .PARAMETER Details
    Additional details about the event (optional)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Load', 'Execute', 'Validation', 'Error', 'Warning', 'Access')]
        [string]$EventType,
        
        [Parameter(Mandatory)]
        [string]$Message,
        
        [Parameter()]
        [string]$Details = ''
    )
    
    try {
        $timestamp = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        $username = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
        $computer = $env:COMPUTERNAME
        
        $logEntry = "[{0}] [{1}] User: {2}, Computer: {3}, Event: {4}, Message: {5}" -f `
            $timestamp, $EventType, $username, $computer, $Message, $Details
        
        # Append to log file (create if doesn't exist)
        Add-Content -LiteralPath $script:AG_SecurityLogPath -Value $logEntry -ErrorAction SilentlyContinue
        
    } catch {
        # Don't throw from logging function - just fail silently
        # We don't want logging errors to break the application
    }
}

function Test-ModuleIntegrity {
    <#
    .SYNOPSIS
    Validates file integrity using SHA256 hash comparison
    
    .PARAMETER FilePath
    Full path to the module file to validate
    
    .PARAMETER FileName
    Name of the file (used to lookup expected hash)
    
    .RETURNS
    $true if file passes integrity check, $false otherwise
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,
        
        [Parameter(Mandatory)]
        [string]$FileName
    )
    
    try {
        # Check if we have expected hashes for this file
        if (-not $script:AG_ModuleHashes.ContainsKey($FileName)) {
            Write-SecurityLog -EventType Warning -Message "No integrity hashes defined for: $FileName" -Details $FilePath
            # For now, log warning but allow execution
            # In production, could enforce hash validation
            return $true
        }
        
        $expectedHashes = $script:AG_ModuleHashes[$FileName]
        if ($expectedHashes.Count -eq 0) {
            Write-SecurityLog -EventType Warning -Message "Empty hash list for: $FileName" -Details $FilePath
            return $true
        }
        
        # Calculate file hash
        $fileHash = Get-FileHash -LiteralPath $FilePath -Algorithm SHA256
        
        # Check if hash matches any expected hash
        if ($expectedHashes -contains $fileHash.Hash) {
            Write-SecurityLog -EventType Validation -Message "Integrity check passed: $FileName" -Details "Hash: $($fileHash.Hash.Substring(0,16))..."
            return $true
        } else {
            Write-SecurityLog -EventType Error -Message "Integrity check FAILED: $FileName" -Details "Hash: $($fileHash.Hash) not in allowlist"
            return $false
        }
        
    } catch {
        Write-SecurityLog -EventType Error -Message "Integrity check error: $FileName" -Details $_.Exception.Message
        return $false
    }
}

function Test-UNCSharePermissions {
    <#
    .SYNOPSIS
    Validates that UNC share is not world-writable or excessively permissive
    
    .PARAMETER UNCPath
    UNC path to validate (e.g., \\server\share)
    
    .RETURNS
    $true if permissions are acceptable, $false if excessive write permissions detected
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$UNCPath
    )
    
    try {
        if (-not (Test-Path -LiteralPath $UNCPath)) {
            Write-SecurityLog -EventType Warning -Message "UNC path not accessible" -Details $UNCPath
            return $false
        }
        
        # Get ACL for the share
        $acl = Get-Acl -LiteralPath $UNCPath -ErrorAction Stop
        
        # Check for excessive permissions (Everyone, Users with Modify/FullControl)
        # Use exact matching to avoid false positives with groups like "PowerUsers"
        $riskyPermissions = $acl.Access | Where-Object {
            $identity = $_.IdentityReference.Value
            (
                $identity -eq 'Everyone' -or
                $identity -eq 'BUILTIN\Users' -or
                $identity -eq 'NT AUTHORITY\Authenticated Users' -or
                $identity -match '\\Users$'
            ) -and
            ($_.FileSystemRights -match '(Modify|FullControl|Write)')
        }
        
        if ($riskyPermissions) {
            $identities = ($riskyPermissions | ForEach-Object { $_.IdentityReference }) -join ', '
            Write-SecurityLog -EventType Warning -Message "Excessive write permissions on UNC share" -Details "Path: $UNCPath, Identities: $identities"
            return $false
        }
        
        Write-SecurityLog -EventType Validation -Message "UNC share permissions validated" -Details $UNCPath
        return $true
        
    } catch {
        Write-SecurityLog -EventType Error -Message "Failed to check UNC permissions" -Details "$UNCPath : $($_.Exception.Message)"
        # On error, allow execution but log warning
        return $true
    }
}

function Assert-SecureModuleLoad {
    <#
    .SYNOPSIS
    Comprehensive security validation before loading a module
    
    .PARAMETER BasePath
    Trusted base folder containing modules
    
    .PARAMETER FileName
    Name of the module file to load
    
    .PARAMETER PerformIntegrityCheck
    Whether to perform hash-based integrity validation
    
    .RETURNS
    Validated absolute path to the module, or throws error if validation fails
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$BasePath,
        
        [Parameter(Mandatory)]
        [string]$FileName,
        
        [Parameter()]
        [switch]$PerformIntegrityCheck
    )
    
    try {
        # 1. Validate base path exists
        if (-not (Test-Path -LiteralPath $BasePath)) {
            Write-SecurityLog -EventType Error -Message "Base path not found" -Details $BasePath
            throw "Base path not found: $BasePath"
        }
        
        # 2. Validate filename is leaf only (no path traversal)
        $leaf = Split-Path -Leaf $FileName
        if ($leaf -ne $FileName) {
            Write-SecurityLog -EventType Error -Message "Path traversal attempt blocked" -Details $FileName
            throw "Blocked module name (must be leaf filename only): $FileName"
        }
        
        # 3. Construct and resolve full path
        $baseResolved = (Resolve-Path -LiteralPath $BasePath -ErrorAction Stop).Path
        $candidate = Join-Path $baseResolved $leaf
        
        if (-not (Test-Path -LiteralPath $candidate)) {
            Write-SecurityLog -EventType Error -Message "Module file not found" -Details $candidate
            throw "Module file not found: $candidate"
        }
        
        $resolved = (Resolve-Path -LiteralPath $candidate -ErrorAction Stop).Path
        
        # 4. Ensure resolved path is under base (prevent symlink/junction attacks)
        # Normalize paths to lowercase for consistent comparison
        $resolvedLower = $resolved.ToLowerInvariant()
        $baseLower = $baseResolved.ToLowerInvariant()
        
        if (-not $resolvedLower.StartsWith($baseLower, [StringComparison]::Ordinal)) {
            Write-SecurityLog -EventType Error -Message "Path outside trusted base" -Details "Base: $baseResolved, Path: $resolved"
            throw "Blocked module path outside trusted base"
        }
        
        # 5. File size validation (prevent DoS from loading extremely large files into memory)
        # 2MB limit chosen to allow reasonably large modules while preventing UI freeze
        # from attempting to load multi-megabyte text files
        $fi = Get-Item -LiteralPath $resolved -ErrorAction Stop
        if ($fi.Length -gt 2MB) {
            Write-SecurityLog -EventType Error -Message "Module file too large" -Details "$leaf ($($fi.Length) bytes)"
            throw "Blocked module (too large): $leaf ($($fi.Length) bytes)"
        }
        
        # 6. Optional: Integrity check
        if ($PerformIntegrityCheck) {
            $integrityOK = Test-ModuleIntegrity -FilePath $resolved -FileName $leaf
            if (-not $integrityOK) {
                # For now, just log warning. In strict mode, could throw here.
                Write-SecurityLog -EventType Warning -Message "Integrity check warning for module" -Details $leaf
            }
        }
        
        # 7. Log successful validation
        Write-SecurityLog -EventType Validation -Message "Module security validation passed" -Details $leaf
        
        return $resolved
        
    } catch {
        Write-SecurityLog -EventType Error -Message "Module security validation failed" -Details "$FileName : $($_.Exception.Message)"
        throw
    }
}

function Initialize-SecuritySubsystem {
    <#
    .SYNOPSIS
    Initialize security subsystem - call this once at application startup
    #>
    [CmdletBinding()]
    param()
    
    try {
        # Create log file if it doesn't exist
        if (-not (Test-Path -LiteralPath $script:AG_SecurityLogPath)) {
            $null = New-Item -Path $script:AG_SecurityLogPath -ItemType File -Force
        }
        
        Write-SecurityLog -EventType Load -Message "Security subsystem initialized" -Details "Log: $script:AG_SecurityLogPath"
        
        # Log application start
        Write-SecurityLog -EventType Load -Message "Application started" -Details "WorkApp/SomearnTK"
        
    } catch {
        # If we can't initialize logging, continue anyway
        # Don't break the application
    }
}

# Auto-initialize when module loads
Initialize-SecuritySubsystem

# Note: Export-ModuleMember is not needed for .txt files that are dot-sourced
# All functions are automatically available in the caller's scope after dot-sourcing
