# TEST_RunMenu_MenuMain_Loading.txt
# Comprehensive test suite for RunMenu → MenuMain loading
# Tests: scope preservation, no loops, no background jobs, successful function loading
# RUN THIS: pwsh -NoProfile -Command "Get-Content './TEST_RunMenu_MenuMain_Loading.txt' -Raw | Invoke-Expression"

$ErrorActionPreference = 'Continue'
$testsPassed = 0
$testsFailed = 0

function Test-Assert {
    param(
        [string]$TestName,
        [bool]$Condition,
        [string]$FailureMessage = ""
    )
    
    if ($Condition) {
        Write-Host "✓ PASS: $TestName" -ForegroundColor Green
        $script:testsPassed++
    } else {
        Write-Host "✗ FAIL: $TestName" -ForegroundColor Red
        if ($FailureMessage) {
            Write-Host "  └─ $FailureMessage" -ForegroundColor Yellow
        }
        $script:testsFailed++
    }
}

Write-Host ""
Write-Host "═══════════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host "  RunMenu → MenuMain Loading Test Suite" -ForegroundColor Cyan
Write-Host "═══════════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host ""

# Detect repository root
$repoRoot = if ($PSScriptRoot) { 
    $PSScriptRoot 
} else { 
    Get-Location 
}
$script:AgScriptsFolder = $repoRoot

Write-Host "[INFO] Test Environment:" -ForegroundColor Cyan
Write-Host "  Repository: $repoRoot"
Write-Host "  AgScriptsFolder: $script:AgScriptsFolder"
Write-Host ""

# ============================================================================
# TEST 1: Verify all required files exist
# ============================================================================
Write-Host "[TEST 1] File Existence Checks" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

$requiredFiles = @(
    'RunMenu.txt',
    'AG_MenuMain.txt',
    'AG_SecurityHelpers.txt',
    'AG_Themes.txt'
)

foreach ($file in $requiredFiles) {
    $path = Join-Path $repoRoot $file
    $exists = Test-Path -LiteralPath $path
    Test-Assert "File exists: $file" $exists "Path: $path"
}

Write-Host ""

# ============================================================================
# TEST 2: Capture initial state (no loops/jobs before loading)
# ============================================================================
Write-Host "[TEST 2] Initial System State (Before Loading)" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

$initialJobs = @(Get-Job -ErrorAction SilentlyContinue)
$initialFunctions = @(Get-Command -CommandType Function -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name)

Test-Assert "No background jobs before loading" ($initialJobs.Count -eq 0) "Found $($initialJobs.Count) jobs"
Write-Host "[INFO] Functions before loading: $($initialFunctions.Count)" -ForegroundColor Cyan

Write-Host ""

# ============================================================================
# TEST 3: Simulate RunMenu.txt loading (dry-run, no WinForms)
# ============================================================================
Write-Host "[TEST 3] RunMenu.txt Loading Simulation" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    # Read RunMenu.txt content
    $runMenuPath = Join-Path $repoRoot 'RunMenu.txt'
    $runMenuContent = Get-Content -LiteralPath $runMenuPath -Raw
    
    Test-Assert "RunMenu.txt is readable" ($runMenuContent.Length -gt 0) "Size: $($runMenuContent.Length) bytes"
    
    # Check for dangerous patterns (exclude comments)
    $codeLines = ($runMenuContent -split "`n") | Where-Object { $_ -notmatch '^\s*#' }
    $codeOnly = $codeLines -join "`n"
    
    $hasSleep = $codeOnly -match 'Start-Sleep|sleep\s'
    Test-Assert "No sleep loops in RunMenu" (-not $hasSleep) "Found Sleep command"
    
    $hasWhileTrue = $codeOnly -match 'while\s*\(\s*\$?true\s*\)|while\s*\(\s*1\s*\)'
    Test-Assert "No infinite while loops in RunMenu" (-not $hasWhileTrue) "Found while(true) pattern"
    
    $hasForever = $codeOnly -match 'for\s*\(\s*;\s*;\s*\)'
    Test-Assert "No infinite for loops in RunMenu" (-not $hasForever) "Found for(;;) pattern"
    
    $hasStartJob = $codeOnly -match 'Start-Job'
    Test-Assert "No background jobs started in RunMenu" (-not $hasStartJob) "Found Start-Job"
    
    $hasTimer = $codeOnly -match 'System\.Timers\.Timer|System\.Windows\.Forms\.Timer'
    Test-Assert "No timers created in RunMenu" (-not $hasTimer) "Found Timer"
    
} catch {
    Test-Assert "RunMenu.txt loading simulation" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 4: Check AG_MenuMain.txt structure
# ============================================================================
Write-Host "[TEST 4] AG_MenuMain.txt Structure Analysis" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    $menuMainPath = Join-Path $repoRoot 'AG_MenuMain.txt'
    $menuMainContent = Get-Content -LiteralPath $menuMainPath -Raw
    
    Test-Assert "AG_MenuMain.txt is readable" ($menuMainContent.Length -gt 0) "Size: $($menuMainContent.Length) bytes"
    
    # Check for entrypoint function
    $hasShowMenuMain = $menuMainContent -match 'function\s+Show-MenuMain\s*\{'
    Test-Assert "Show-MenuMain function exists" $hasShowMenuMain "Entrypoint not found"
    
    # Check for dangerous patterns (exclude comments)
    $codeLines = ($menuMainContent -split "`n") | Where-Object { $_ -notmatch '^\s*#' }
    $codeOnly = $codeLines -join "`n"
    
    $hasSleep = $codeOnly -match 'Start-Sleep|sleep\s'
    Test-Assert "No sleep loops in MenuMain" (-not $hasSleep) "Found Sleep command"
    
    $hasWhileTrue = $codeOnly -match 'while\s*\(\s*\$?true\s*\)|while\s*\(\s*1\s*\)'
    Test-Assert "No infinite while loops in MenuMain" (-not $hasWhileTrue) "Found while(true) pattern"
    
    $hasStartJob = $codeOnly -match 'Start-Job'
    Test-Assert "No background jobs in MenuMain" (-not $hasStartJob) "Found Start-Job"
    
    $hasTimer = $codeOnly -match 'System\.Timers\.Timer|System\.Windows\.Forms\.Timer'
    Test-Assert "No timers in MenuMain" (-not $hasTimer) "Found Timer"
    
    # Check for proper dot-sourcing (not Invoke-Expression) - exclude comments
    $hasInvokeExpression = $codeOnly -match 'Invoke-Expression|iex\s+'
    Test-Assert "No Invoke-Expression in MenuMain" (-not $hasInvokeExpression) "Found Invoke-Expression"
    
    $hasScriptBlockCreate = $codeOnly -match '\[scriptblock\]::Create'
    Test-Assert "No ScriptBlock::Create in MenuMain" (-not $hasScriptBlockCreate) "Found ScriptBlock::Create"
    
} catch {
    Test-Assert "AG_MenuMain.txt analysis" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 5: Verify module loading sequence
# ============================================================================
Write-Host "[TEST 5] Module Loading Sequence (Static Analysis)" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    $runMenuContent = Get-Content -LiteralPath (Join-Path $repoRoot 'RunMenu.txt') -Raw
    
    # Check that AG_SecurityHelpers loads first
    $securityHelpersIndex = $runMenuContent.IndexOf('AG_SecurityHelpers.txt')
    $menuMainIndex = $runMenuContent.IndexOf('AG_MenuMain.txt')
    
    Test-Assert "SecurityHelpers loads before MenuMain" ($securityHelpersIndex -lt $menuMainIndex -and $securityHelpersIndex -gt 0) `
        "SecurityHelpers at $securityHelpersIndex, MenuMain at $menuMainIndex"
    
    # Check for inline dot-sourcing (not in helper function)
    $menuMainDotSource = $runMenuContent -match '\.\s+\$menuPath'
    Test-Assert "MenuMain dot-sourced inline (not in function)" $menuMainDotSource "Must be at top scope"
    
} catch {
    Test-Assert "Module loading sequence check" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 6: Verify path resolution logic
# ============================================================================
Write-Host "[TEST 6] Path Resolution Logic" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    # Simulate the path resolution from RunMenu.txt
    if ($script:AgScriptsFolder -and (Test-Path -LiteralPath $script:AgScriptsFolder)) {
        $script:AG_AppDataPath = $script:AgScriptsFolder
        $script:AG_AppScriptsPath = $script:AgScriptsFolder
    } else {
        $script:AG_AppDataPath = '\\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appdata'
        $script:AG_AppScriptsPath = '\\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appscripts'
    }
    
    Test-Assert "AG_AppDataPath is set" (-not [string]::IsNullOrWhiteSpace($script:AG_AppDataPath)) "Path: $script:AG_AppDataPath"
    Test-Assert "AG_AppScriptsPath is set" (-not [string]::IsNullOrWhiteSpace($script:AG_AppScriptsPath)) "Path: $script:AG_AppScriptsPath"
    
    $appDataExists = Test-Path -LiteralPath $script:AG_AppDataPath
    Test-Assert "AG_AppDataPath exists" $appDataExists "Path: $script:AG_AppDataPath"
    
    # Check RunMenu.txt for typo (should be Somearns_Folder not Somearn_Folder)
    $runMenuContent = Get-Content -LiteralPath (Join-Path $repoRoot 'RunMenu.txt') -Raw
    $hasTypo = $runMenuContent -match "Somearn_Folder[^s]"
    Test-Assert "No typo in RunMenu (Somearns not Somearn)" (-not $hasTypo) "Found typo: Somearn_Folder"
    
} catch {
    Test-Assert "Path resolution logic" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 7: Validate no recursive loading
# ============================================================================
Write-Host "[TEST 7] Recursive Loading Detection" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    # Check RunMenu doesn't load itself
    $runMenuContent = Get-Content -LiteralPath (Join-Path $repoRoot 'RunMenu.txt') -Raw
    $loadsItself = $runMenuContent -match '\.\s+.*RunMenu\.txt'
    Test-Assert "RunMenu does not load itself" (-not $loadsItself) "Found self-reference"
    
    # Check MenuMain doesn't load RunMenu
    $menuMainContent = Get-Content -LiteralPath (Join-Path $repoRoot 'AG_MenuMain.txt') -Raw
    $loadsRunMenu = $menuMainContent -match 'RunMenu\.txt'
    Test-Assert "MenuMain does not load RunMenu" (-not $loadsRunMenu) "Found RunMenu reference"
    
} catch {
    Test-Assert "Recursive loading check" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 8: Function scope preservation check
# ============================================================================
Write-Host "[TEST 8] Function Scope Preservation" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    # Verify inline dot-sourcing comment exists
    $runMenuContent = Get-Content -LiteralPath (Join-Path $repoRoot 'RunMenu.txt') -Raw
    $hasInlineComment = $runMenuContent -match 'Dot-source at top scope'
    Test-Assert "Comment about top-scope dot-sourcing exists" $hasInlineComment "Documentation missing"
    
    # Verify no function wrappers around module loading
    $hasFunctionWrapper = $runMenuContent -match 'function.*\{.*\.\s+\$menuPath'
    Test-Assert "MenuMain not loaded inside helper function" (-not $hasFunctionWrapper) "Found function wrapper"
    
} catch {
    Test-Assert "Scope preservation check" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 9: Check for launcher consistency
# ============================================================================
Write-Host "[TEST 9] Launcher Files Consistency" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

try {
    $launcherTxt = Get-Content -LiteralPath (Join-Path $repoRoot 'Launcher code (Run this PowerShell ISE).txt') -Raw
    $launcherPs1Path = Join-Path $repoRoot 'Launcher.ps1'
    
    # Both should have fallback logic
    $txtHasFallback = $launcherTxt -match 'Test-RunMenuPath'
    Test-Assert "Launcher txt has fallback logic" $txtHasFallback "Missing Test-RunMenuPath"
    
    if (Test-Path -LiteralPath $launcherPs1Path) {
        $launcherPs1 = Get-Content -LiteralPath $launcherPs1Path -Raw
        $ps1HasFallback = $launcherPs1 -match 'Test-RunMenuPath'
        Test-Assert "Launcher ps1 has fallback logic" $ps1HasFallback "Missing Test-RunMenuPath"
        
        # Both should use direct dot-sourcing
        $ps1DotSource = $launcherPs1 -match '\.\s+\$runMenuPath'
        Test-Assert "Launcher ps1 uses dot-sourcing" $ps1DotSource "Not using dot-source"
    } else {
        Write-Host "[INFO] Launcher.ps1 not found (text-file-only mode)" -ForegroundColor Cyan
    }
    
    # Check txt launcher uses dot-sourcing
    $txtDotSource = $launcherTxt -match '\.\s+\$runMenuPath'
    Test-Assert "Launcher txt uses dot-sourcing" $txtDotSource "Not using dot-source"
    
} catch {
    Test-Assert "Launcher consistency check" $false $_.Exception.Message
}

Write-Host ""

# ============================================================================
# TEST 10: Final state check (no new jobs/loops)
# ============================================================================
Write-Host "[TEST 10] Final System State (After Analysis)" -ForegroundColor Yellow
Write-Host "─────────────────────────────────────────────────────────────"

$finalJobs = @(Get-Job -ErrorAction SilentlyContinue)
$finalFunctions = @(Get-Command -CommandType Function -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name)

Test-Assert "No new background jobs created" ($finalJobs.Count -eq $initialJobs.Count) `
    "Started with $($initialJobs.Count), now have $($finalJobs.Count)"

$newFunctions = $finalFunctions | Where-Object { $initialFunctions -notcontains $_ }
Write-Host "[INFO] Test functions added: $($newFunctions.Count)" -ForegroundColor Cyan

Write-Host ""

# ============================================================================
# SUMMARY
# ============================================================================
Write-Host "═══════════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host "  Test Suite Summary" -ForegroundColor Cyan
Write-Host "═══════════════════════════════════════════════════════════" -ForegroundColor Cyan
Write-Host ""
Write-Host "Total Tests Run: $($testsPassed + $testsFailed)" -ForegroundColor White
Write-Host "Tests Passed:    $testsPassed" -ForegroundColor Green
Write-Host "Tests Failed:    $testsFailed" -ForegroundColor $(if ($testsFailed -eq 0) { 'Green' } else { 'Red' })
Write-Host ""

if ($testsFailed -eq 0) {
    Write-Host "✓ ALL TESTS PASSED" -ForegroundColor Green
    Write-Host "  RunMenu → MenuMain loading is safe:" -ForegroundColor Green
    Write-Host "  • No infinite loops" -ForegroundColor Green
    Write-Host "  • No background jobs" -ForegroundColor Green
    Write-Host "  • No timers" -ForegroundColor Green
    Write-Host "  • Proper scope preservation" -ForegroundColor Green
    Write-Host "  • No recursive loading" -ForegroundColor Green
    Write-Host "  • Direct dot-sourcing (no IEX/ScriptBlock::Create)" -ForegroundColor Green
} else {
    Write-Host "✗ SOME TESTS FAILED" -ForegroundColor Red
    Write-Host "  Please review failures above." -ForegroundColor Red
}

Write-Host ""
Write-Host "Test completed. Exit code: $(if ($testsFailed -eq 0) { 0 } else { 1 })" -ForegroundColor Cyan
