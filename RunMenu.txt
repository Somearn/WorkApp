# RunMenu.txt  (TXT-only)
# SomearnTK - Startup Router (SCOPE-FIXED)
#
# Your environment:
# - Modules/Menu/Tools live in: \\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appdata
# - Script inventory lives in: \\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appscripts
#
# CRITICAL SCOPE RULE:
# - Do NOT dot-source AG_*.txt modules inside a helper function.
#   That traps exported functions inside that function scope.
# - This loader dot-sources modules INLINE at top scope so Show-MenuMain persists.
#
$ErrorActionPreference = 'Stop'
$WarningPreference     = 'SilentlyContinue'
$ProgressPreference    = 'SilentlyContinue'

Add-Type -AssemblyName System.Windows.Forms | Out-Null
Add-Type -AssemblyName System.Drawing       | Out-Null
[System.Windows.Forms.Application]::EnableVisualStyles()

function _MsgErr([string]$t){ [System.Windows.Forms.MessageBox]::Show($t,'SomearnTK','OK','Error') | Out-Null }
function _MsgInfo([string]$t){ [System.Windows.Forms.MessageBox]::Show($t,'SomearnTK','OK','Information') | Out-Null }

# ---- Hard paths ----
# If AgScriptsFolder was set by the launcher, use it; otherwise use production UNC paths
if ($script:AgScriptsFolder -and (Test-Path -LiteralPath $script:AgScriptsFolder)) {
    $script:AG_AppDataPath    = $script:AgScriptsFolder
    # In local dev, both modules and scripts are in same folder (no separate appscripts directory)
    $script:AG_AppScriptsPath = $script:AgScriptsFolder
} else {
    $script:AG_AppDataPath    = '\\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appdata'
    $script:AG_AppScriptsPath = '\\lsfile03\netdoc$\Somearns_Folder\SomearnTK_app\appscripts'
}

if (-not (Test-Path -LiteralPath $script:AG_AppDataPath)) {
    _MsgErr "Startup failed:`r`nAppData path not found:`r`n$script:AG_AppDataPath"
    return
}

# Load security helpers early (if available)
$securityHelpersPath = Join-Path $script:AG_AppDataPath 'AG_SecurityHelpers.txt'
if (Test-Path -LiteralPath $securityHelpersPath) {
    try {
        . $securityHelpersPath
        # Test UNC share permissions (log warning if excessive)
        Test-UNCSharePermissions -UNCPath $script:AG_AppDataPath | Out-Null
    } catch {
        # If security helpers fail, log to Windows Event Log as fallback
        _MsgErr ("Security helpers failed to load.`r`nSecurity events will be logged to Windows Event Log.`r`n`r`n{0}" -f $_.Exception.Message)
        
        function Write-SecurityLog {
            param($EventType, $Message, $Details)
            
            $fullMessage = if ($Details) {
                "$Message`r`nDetails: $Details"
            } else {
                $Message
            }
            
            try {
                $source = 'SomearnTK'
                $logName = 'Application'
                
                # Create event source if it doesn't exist (requires admin)
                if (-not [System.Diagnostics.EventLog]::SourceExists($source)) {
                    try {
                        [System.Diagnostics.EventLog]::CreateEventSource($source, $logName)
                    } catch {
                        # If we can't create source (non-admin), log will fail silently
                    }
                }
                
                $entryType = [System.Diagnostics.EventLogEntryType]::Information
                if ($EventType -match 'Error') {
                    $entryType = [System.Diagnostics.EventLogEntryType]::Error
                } elseif ($EventType -match 'Warning') {
                    $entryType = [System.Diagnostics.EventLogEntryType]::Warning
                }
                
                [System.Diagnostics.EventLog]::WriteEntry($source, $fullMessage, $entryType)
            } catch {
                # Silently fail if logging is not possible
            }
        }
    }
} else {
    # Security helpers not available: define a fallback logger
    _MsgErr "Security helpers file not found. Security events will be logged to Windows Event Log if possible."
    
    function Write-SecurityLog {
        param($EventType, $Message, $Details)
        
        $fullMessage = if ($Details) {
            "$Message`r`nDetails: $Details"
        } else {
            $Message
        }
        
        try {
            $source = 'SomearnTK'
            $logName = 'Application'
            
            if (-not [System.Diagnostics.EventLog]::SourceExists($source)) {
                try {
                    [System.Diagnostics.EventLog]::CreateEventSource($source, $logName)
                } catch {
                    # If we can't create source (non-admin), log will fail silently
                }
            }
            
            $entryType = [System.Diagnostics.EventLogEntryType]::Information
            if ($EventType -match 'Error') {
                $entryType = [System.Diagnostics.EventLogEntryType]::Error
            } elseif ($EventType -match 'Warning') {
                $entryType = [System.Diagnostics.EventLogEntryType]::Warning
            }
            
            [System.Diagnostics.EventLog]::WriteEntry($source, $fullMessage, $entryType)
        } catch {
            # Silently fail if logging is not possible
        }
    }
}

# NOTE: AgScriptsFolder is a legacy variable name from an earlier version of this toolkit.
# Despite its name, it actually points to the module root (appdata) where AG_*.txt module files are stored.
# This is used by AG_MenuMain's Import-AG_TxtModuleSafe function to load modules.
# For script inventory (user scripts), use AG_ScriptsInventoryPath instead.
$script:AgScriptsFolder = $script:AG_AppDataPath

# Expose appscripts inventory path for tools like Script Launcher (listing only)
$script:AG_ScriptsInventoryPath = $script:AG_AppScriptsPath

# Snapshot functions BEFORE loading MenuMain (diagnostic only)
$__beforeFns = @()
try { $__beforeFns = (Get-Command -CommandType Function -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name) } catch { $__beforeFns = @() }

# --- Optional: Themes ---
# SECURITY FIX: Use direct dot-sourcing instead of ScriptBlock::Create to avoid EDR flagging
try {
    $themePath = Join-Path $script:AG_AppDataPath 'AG_Themes.txt'
    if (Test-Path -LiteralPath $themePath) {
        . $themePath
    }
} catch {
    _MsgErr ("Theme load failed:`r`n{0}`r`n`r`n{1}" -f $themePath, $_.Exception.Message)
    return
}

# --- Required: MenuMain (INLINE dot-source to preserve Show-MenuMain) ---
$menuPath = Join-Path $script:AG_AppDataPath 'AG_MenuMain.txt'
if (-not (Test-Path -LiteralPath $menuPath)) {
    _MsgErr "Startup failed:`r`nMissing module file:`r`n$menuPath"
    return
}

# SECURITY FIX: Use direct dot-sourcing instead of ScriptBlock::Create to avoid EDR flagging
try {
    # Dot-source at top scope, not inside a helper function, to preserve Show-MenuMain
    . $menuPath
} catch {
    _MsgErr ("Startup failed loading:`r`n{0}`r`n`r`n{1}" -f $menuPath, $_.Exception.Message)
    return
}

# Snapshot functions AFTER loading MenuMain (diagnostic only)
$__afterFns = @()
try { $__afterFns = (Get-Command -CommandType Function -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Name) } catch { $__afterFns = @() }

# Identify what AG_MenuMain actually added
$__added = @()
try {
    $setBefore = New-Object 'System.Collections.Generic.HashSet[string]' ([StringComparer]::OrdinalIgnoreCase)
    foreach ($b in $__beforeFns) { [void]$setBefore.Add($b) }
    foreach ($a in $__afterFns)  { if (-not $setBefore.Contains($a)) { $__added += $a } }
} catch { $__added = @() }

# Entrypoint check (try both common names)
$cmd = Get-Command -Name 'Show-MenuMain' -ErrorAction SilentlyContinue
if (-not $cmd) { $cmd = Get-Command -Name 'Show-Menu' -ErrorAction SilentlyContinue }

if (-not $cmd) {
    # Diagnostics (kept short but actionable)
    $fi = $null
    try { $fi = Get-Item -LiteralPath $menuPath -ErrorAction Stop } catch {}
    $meta = if ($fi) {
        "Path:`r`n$menuPath`r`n`r`nSize:`r`n$($fi.Length) bytes`r`n`r`nLastWrite:`r`n$($fi.LastWriteTime)"
    } else {
        "Path:`r`n$menuPath"
    }

    $addedPreview = if ($__added -and $__added.Count -gt 0) { ($__added | Sort-Object | Select-Object -First 25) -join ', ' } else { '(none)' }

    _MsgErr ("Startup failed:`r`nAG_MenuMain.txt loaded, but no Show-MenuMain entrypoint was found.`r`n`r`n{0}`r`n`r`nNew functions added by AG_MenuMain load (top 25):`r`n{1}" -f $meta, $addedPreview)
    return
}

# Launch menu
try {
    & $cmd.Name
} catch {
    _MsgErr ("Menu crashed:`r`n{0}" -f $_.Exception.Message)
}
